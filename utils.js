import e from "express";

export const WINNING_COMBINATIONS = [
  [0, 1, 2], [3, 4, 5], [6, 7, 8], // –ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã–µ
  [0, 3, 6], [1, 4, 7], [2, 5, 8], // –í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã–µ
  [0, 4, 8], [2, 4, 6]  // –î–∏–∞–≥–æ–Ω–∞–ª—å–Ω—ã–µ
];

export const calculateWinner = (squares, gameMode) => {
  const lines = [
      [0, 1, 2],
      [3, 4, 5],
      [6, 7, 8],
      [0, 3, 6],
      [1, 4, 7],
      [2, 5, 8],
      [0, 4, 8],
      [2, 4, 6],
  ];

  if (gameMode === 'Half') {
      // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ–±–µ–¥–∏—Ç–µ–ª—è –≤ "Half" —Ä–µ–∂–∏–º–µ
      for (const [a, b, c] of lines) {
          if ([a, b, c].every((index) => !squares[index]?.includes('HALF')) && squares[a] && squares[a] === squares[b] && squares[a] === squares[c]) {
              return { winner: squares[a], combination: [a, b, c] };
          }
      }

      // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å–ª–∏ –≤—Å–µ –∫–ª–µ—Ç–∫–∏ –∑–∞–Ω—è—Ç—ã –∏ –Ω–µ —Å–æ–¥–µ—Ä–∂–∞—Ç "HALF"
      if (squares.every((square) => square !== null && !square.includes('HALF'))) {
          return { winner: '–ù–∏—á—å—è', combination: null };
      }

      // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –∑–∞–ø–µ—Ä—Ç—É—é —Å–∏—Ç—É–∞—Ü–∏—é
      const halfCells = squares.filter((square) => square?.includes('HALF'));
      const filledCells = squares.filter((square) => square !== null && !square.includes('HALF'));
      if (halfCells.length === 1 && filledCells.length === squares.length - 1) {
          return { winner: '–ù–∏—á—å—è', combination: null };
      }
  } else if (gameMode === 'Standard' || gameMode === 'AI_Standard') {
      // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ–±–µ–¥–∏—Ç–µ–ª—è –≤ –æ–±—ã—á–Ω–æ–º —Ä–µ–∂–∏–º–µ
      for (const [a, b, c] of lines) {
        if (squares[a] && squares[a] === squares[b] && squares[a] === squares[c]) {
            return { winner: squares[a], combination: [a, b, c] };
        }
      }
      if (squares.every((square) => square !== null)) {
        return { winner: '–ù–∏—á—å—è', combination: null };
      }
  }

  return null;
};


export const definedRole = (roomPlayers) => {
    // –ï—Å–ª–∏ –Ω–µ—Ç –∏–≥—Ä–æ–∫–æ–≤, —Å–ª—É—á–∞–π–Ω–æ –Ω–∞–∑–Ω–∞—á–∞–µ–º X –∏–ª–∏ O
    if (roomPlayers.length === 0) {
      return Math.random() > 0.5 ? 'X' : 'O';
    }
  
    // –ï—Å–ª–∏ –æ–¥–∏–Ω –∏–≥—Ä–æ–∫ —É–∂–µ –µ—Å—Ç—å, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –ø—Ä–æ—Ç–∏–≤–æ–ø–æ–ª–æ–∂–Ω—É—é —Ä–æ–ª—å
    if (roomPlayers.length === 1) {
      return roomPlayers[0].role === 'X' ? 'O' : 'X';
    }
  
    // –ï—Å–ª–∏ —É–∂–µ –¥–≤–∞ –∏–≥—Ä–æ–∫–∞, –Ω–µ –Ω–∞–∑–Ω–∞—á–∞–µ–º —Ä–æ–ª—å (–æ—à–∏–±–∫–∞)
    throw new Error('–ö–æ–º–Ω–∞—Ç–∞ —É–∂–µ –∑–∞–ø–æ–ª–Ω–µ–Ω–∞.');
};

export const defineSkills = () => {
  const skillsConfig = {
    borrow: { base: 3, max: 4, chance: 0.5 },
    lock: { base: 2, max: 3, chance: 0.5 },
    unlock: { base: 1, max: 2, chance: 0.5 },
  };

  const skills = {};

  Object.keys(skillsConfig).forEach((skill) => {
    const { base, max, chance } = skillsConfig[skill];
    skills[skill] = Math.random() < chance ? max : base;
  });

  return skills;
};

export function formatMovesHistory(moves) {
  if (!moves || moves.length === 0) {
    return "No moves history.";
  }

  return moves
    .slice(-3) // –ë–µ—Ä—ë–º –ø–æ—Å–ª–µ–¥–Ω–∏–µ 3 —Ö–æ–¥–∞
    .map(
      (move) =>
        `${move.moveNumber}. ${move.player === "user" ? "User" : "AI-bot"} placed ${move.role} at position ${move.position}`
    )
    .join("\n");
}

// const systemPrompt = `
//       –¢—ã –ø—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω—ã–π –∏–≥—Ä–æ–∫ –≤ –∫—Ä–µ—Å—Ç–∏–∫–∏-–Ω–æ–ª–∏–∫–∏. –¢–≤–æ—è –∑–∞–¥–∞—á–∞ ‚Äî –æ–±—ã–≥—Ä–∞—Ç—å —Å–æ–ø–µ—Ä–Ω–∏–∫–∞, –∞–Ω–∞–ª–∏–∑–∏—Ä—É—è –∫–æ–º–±–∏–Ω–∞—Ü–∏–∏.

//       –ü—Ä–∞–≤–∏–ª–∞:
//       0. –ü—Ä–∏–º–µ—Ä –ø—É—Å—Ç–æ–π –¥–æ—Å–∫–∏: [ null, null, null, null, null, null, null, null, null ]
//       1. –£ –Ω–∞—Å –º–∞—Å—Å–∏–≤ –∏–∑ 9 –ø–æ–∑–∏—Ü–∏–π (0..8). –ï—Å–ª–∏ –∫–ª–µ—Ç–∫–∞ –∑–∞–Ω—è—Ç–∞, —Ç–∞–º "X" –∏–ª–∏ "O", –ø–æ –∏–Ω–¥–µ–∫—Å–∞–º –∑–∞–Ω—è—Ç—ã—Ö –∫–ª–µ—Ç–æ–∫ —Ö–æ–¥–∏—Ç—å –Ω–µ–ª—å–∑—è. –ï—Å–ª–∏ –∫–ª–µ—Ç–∫–∞ —Å–≤–æ–±–æ–¥–Ω–∞, —Ç–∞–º "null".
//       2. –ú–∞—Å—Å–∏–≤ –≤—ã–∏–≥—Ä—ã—à–Ω—ã—Ö –∫–æ–º–±–∏–Ω–∞—Ü–∏–π: ${WINNING_COMBINATIONS}.
//       3. –¢–µ–±–µ –∫–∞–∂–¥—ã–π —Ö–æ–¥ –Ω–∞–¥–æ –ø—Ä–æ–±–µ–∂–∞—Ç—å—Å—è –ø–æ –º–∞—Å—Å–∏–≤—É –º–∞—Å—Å–∏–≤–æ–≤ —Å –≤—ã–∏–≥—Ä—ã—à–Ω—ã–º–∏ –∫–æ–º–±–∏–Ω–∞—Ü–∏—è–º–∏, —Å–≤–µ—Ä–∏—Ç—å –∏—Ö —Å —Ç–µ–∫—É—â–∏–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ–º –¥–æ—Å–∫–∏, –µ—Å–ª–∏ –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫ '${opponent}' —É–∂–µ –∏–º–µ–µ—Ç 2 –∏–Ω–¥–µ–∫—Å–∞ –∏–∑ –æ–¥–Ω–æ–π –∏–∑ –ø–æ–±–µ–¥–Ω—ã—Ö –∫–æ–º–±–∏–Ω–∞—Ü–∏–π, —Ç–µ–±–µ –Ω—É–∂–Ω–æ –∑–∞–Ω–∏–º–∞—Ç—å —Ç—Ä–µ—Ç—å—é, –≤ –ø—Ä–æ—Ç–∏–≤–Ω–æ–º —Å–ª—É—á–∞–µ –ø—ã—Ç–∞—Ç—å—Å—è –∑–∞–≤–µ—Ä—à–∏—Ç—å —Å–≤–æ—é –ø–æ–±–µ–¥–Ω—É—é –∫–æ–º–±–∏–Ω–∞—Ü–∏—é –∏–∑ —Ç—Ä–µ—Ö ${role}.
//       4. –¢—ã –∏–≥—Ä–∞–µ—à—å –∑–∞ ${role}, —Å–æ–ø–µ—Ä–Ω–∏–∫ –∑–∞ ${opponent}.
//       5. –ï—Å–ª–∏ —Å–æ–ø–µ—Ä–Ω–∏–∫ –º–æ–∂–µ—Ç –≤—ã–∏–≥—Ä–∞—Ç—å —Å–ª–µ–¥—É—é—â–∏–º —Ö–æ–¥–æ–º (—É –Ω–µ–≥–æ —É–∂–µ –µ—Å—Ç—å 2 –∫–ª–µ—Ç–∫–∏ –≤ –æ–¥–Ω–æ–π –∫–æ–º–±–∏–Ω–∞—Ü–∏–∏, –∞ —Ç—Ä–µ—Ç—å—è "null"), –±–ª–æ–∫–∏—Ä—É–π –Ω–µ–º–µ–¥–ª–µ–Ω–Ω–æ.
//       6. –ï—Å–ª–∏ —Å–∞–º –º–æ–∂–µ—à—å –≤—ã–∏–≥—Ä–∞—Ç—å (2 –∫–ª–µ—Ç–∫–∏ —Ç–≤–æ–µ–≥–æ —Å–∏–º–≤–æ–ª–∞ –∏ —Ç—Ä–µ—Ç—å—è "null"), —Å—Ç–∞–≤—å —Ç—É–¥–∞, —á—Ç–æ–±—ã —Å—Ä–∞–∑—É –≤—ã–∏–≥—Ä–∞—Ç—å.
//       7. –ï—Å–ª–∏ –Ω–µ—Ç –ø—Ä—è–º–æ–π –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏ –∏–ª–∏ –≤—ã–∏–≥—Ä—ã—à–∞, –≤—ã–±–µ—Ä–∏ —Ö–æ–¥, –∫–æ—Ç–æ—Ä—ã–π –ø–æ–º–æ–≥–∞–µ—Ç —Å—Ñ–æ—Ä–º–∏—Ä–æ–≤–∞—Ç—å —Ç–≤–æ—é –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω—É—é –≤—ã–∏–≥—Ä—ã—à–Ω—É—é –ª–∏–Ω–∏—é.
//       8. –û—Ç–≤–µ—Ç –≤—Å–µ–≥–¥–∞ –¥–∞–≤–∞–π —Å—Ç—Ä–æ–≥–æ –≤ —Ñ–æ—Ä–º–∞—Ç–µ: "–ò–Ω–¥–µ–∫—Å: N" (0..8), –±–µ–∑ –ø–æ—è—Å–Ω–µ–Ω–∏–π.

//       –ü—Ä–∏–º–µ—Ä: 
//       –ï—Å–ª–∏ –±—ã —Ç—ã –∏–≥—Ä–∞–ª –∑–∞ "${role}", –∞ —Ç–µ–∫—É—â–∞—è –¥–æ—Å–∫–∞ –±—ã–ª–∞
//       –¢–µ–∫—É—â–∞—è –¥–æ—Å–∫–∞: [ '${opponent}', null, '${role}', null, '${opponent}', null, null, null, null ] (—Ç—É—Ç –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫ –∏–≥—Ä–∞–µ—Ç –∑–∞ "${opponent}" –∏ —É–≥—Ä–æ–∂–∞–µ—Ç –≤—ã–∏–≥—Ä–∞—Ç—å –≤ —Å–ª–µ–¥—É—é—â–µ–º —Ö–æ–¥—É –ø–æ—Ö–æ–¥–∏–≤ –≤ –∏–Ω–¥–µ–∫—Å 8, –Ω–∞–¥–æ —Å—Ä–æ—á–Ω–æ –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å –µ–º—É –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –≤—ã–∏–≥—Ä–∞—Ç—å –ø–æ–∫–∞ –Ω–∞—à —Ö–æ–¥, –ø–æ—Å—Ç–∞–≤–∏–≤ ${role} –≤ –∏–Ω–¥–µ–∫—Å 8)
//       –û—Ç–≤–µ—Ç: "–ò–Ω–¥–µ–∫—Å: 8"
//     `.trim();

// const systemPrompt = `
// You are an AI-bot playing tic-tac-toe. Your task is to evaluate the current board state and make the optimal move. You play as "${role}", and your opponent plays as "${opponent}".

// **Rules for making a move:**

// 1 **BLOCK OPPONENT'S WINNING MOVE FIRST**  
//  - If the opponent (${opponent}) has two marks in a winning combination and the third spot is empty ‚Üí **immediately block it!**

// 2 **MAKE A WINNING MOVE SECOND**  
//  - If you (${role}) have two marks in a winning combination and the third spot is empty ‚Üí **immediately place your mark there to win!**

// 3 **STRATEGIC MOVES (ONLY IF NO THREAT OR WIN)**
//  - If the center (Index: 4) is empty, place "${role}" there.
//  - Otherwise, pick the best available move following the **WINNING_COMBINATIONS**:  ${JSON.stringify(WINNING_COMBINATIONS)}
// **Current board state:**  
// ${JSON.stringify(boardArray)}
   
//   0 | 1 | 2    =>    . | . | .
//   ---+---+---
//   3 | 4 | 5    =>    . | . | .
//   ---+---+---
//   6 | 7 | 8    =>    . | . | .

//   or in array notation:
//   [0, 1, 2, 3, 4, 5, 6, 7, 8]
//   but clear desk looks like: [null, null, null, null, null, null, null, null, null] , "null" means empty cell you can play there once you make your move.

// Keep in mind:
// - "${role}" represents your positions on the board array.
// - "${opponent}" represents your opponent's positions on the board array.
// - "null" represents an empty position where you can place your move.
// **Your move must be returned in this format:**  
//   "Index: N" (where N is the chosen position).
// `.trim();


  //   const userPrompt = `
  //   The game continues.
  //   Here is the moves history:
  //   ${movesHistory}

  //   Your turn! Place ${role} on the board to prevent me from winning!
  //   My last move was at position: ${usersStep}, playing as "${opponent}".
  //   Current board state: board = ${JSON.stringify(boardArray)}.
  //   Respond only with: "Index: N".
  // `.trim();

  export function findStrategicMove(squares, role) {
    const opponent = role === 'X' ? 'O' : 'X';


    let winningMove = null;
    let blockingMove = null;
    const recommendedMoves = {};
    const notRecommendedMoves = {};
  
    for (const combination of WINNING_COMBINATIONS) {
      let botCount = 0;
      let opponentCount = 0;
      const emptyCells = [];
  
      for (const index of combination) {
        if (squares[index] === role) botCount++;
        else if (squares[index] === opponent) opponentCount++;
        else emptyCells.push(index);
      }
  
      if (botCount === 2 && emptyCells.length === 1) {
        // console.log(`üéØ –ù–∞–π–¥–µ–Ω –ø–æ–±–µ–¥–Ω—ã–π —Ö–æ–¥: ${emptyCells[0]}`);
        winningMove = emptyCells[0];
      }
      if (opponentCount === 2 && emptyCells.length === 1) {
        // console.log(`‚ö† –ù–∞–π–¥–µ–Ω–∞ —É–≥—Ä–æ–∑–∞, –±–ª–æ–∫–∏—Ä—É–µ–º —Ö–æ–¥: ${emptyCells[0]}`);
        blockingMove = emptyCells[0];
      }
      
      if (botCount === 1 && opponentCount === 1 && emptyCells.length === 1) {
        const cell = emptyCells[0];
        notRecommendedMoves[cell] = (notRecommendedMoves[cell] || 0) + 1;
      }
      if (botCount === 1 && opponentCount === 0 && emptyCells.length === 2) {
        emptyCells.forEach(cell => {
          recommendedMoves[cell] = (recommendedMoves[cell] || 0) + 1;
        });
      }
      if (botCount === 0 && opponentCount === 1 && emptyCells.length === 2) {
        emptyCells.forEach(cell => {
          recommendedMoves[cell] = (recommendedMoves[cell] || 0) + 1;
        });
      }
    }
    // console.log("–°—Ç—Ä–∞—Ç–µ–≥–∏—á–µ—Å–∫–æ–≥–æ —Ö–æ–¥–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ üö´:", null);
    // console.log("‚úÖ –†–µ–∫–æ–º–µ–Ω–¥–æ–≤–∞–Ω–Ω—ã–µ —Ö–æ–¥—ã:", recommendedMoves);
    // console.log("üö´ –ù–µ —Ä–µ–∫–æ–º–µ–Ω–¥—É–µ–º—ã–µ —Ö–æ–¥—ã:", notRecommendedMoves);

    const strategicMove = winningMove || blockingMove;
  
    return { strategicMove, recommendedMoves, notRecommendedMoves };
  }

  export function getTopMoves(recommendedMoves, notRecommendedMoves) {
    // –ü–æ–ª—É—á–∞–µ–º –º–∞—Å—Å–∏–≤ –∏–∑ —Ä–µ–∫–æ–º–µ–Ω–¥—É–µ–º—ã—Ö —Ö–æ–¥–æ–≤, —Å–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ —É–±—ã–≤–∞–Ω–∏—é –∑–Ω–∞—á–µ–Ω–∏–π
    const sortedRecommended = Object.entries(recommendedMoves)
      .sort((a, b) => b[1] - a[1]) // –°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –ø–æ —É–±—ã–≤–∞–Ω–∏—é (–ª—É—á—à–∏–µ —Ö–æ–¥—ã –≤ –Ω–∞—á–∞–ª–µ)
      .map(([key]) => Number(key)); // –ë–µ—Ä–µ–º —Ç–æ–ª—å–∫–æ –∏–Ω–¥–µ–∫—Å—ã (–∫–ª—é—á–∏)
  
    // –ü–æ–ª—É—á–∞–µ–º –º–∞—Å—Å–∏–≤ –∏–∑ –Ω–µ—Ä–µ–∫–æ–º–µ–Ω–¥—É–µ–º—ã—Ö —Ö–æ–¥–æ–≤, —Å–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ —É–±—ã–≤–∞–Ω–∏—é –∑–Ω–∞—á–µ–Ω–∏–π
    const sortedNotRecommended = Object.entries(notRecommendedMoves)
      .sort((a, b) => b[1] - a[1]) // –°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –ø–æ —É–±—ã–≤–∞–Ω–∏—é (—Ö—É–¥—à–∏–µ —Ö–æ–¥—ã –≤ –Ω–∞—á–∞–ª–µ)
      .map(([key]) => Number(key)); // –ë–µ—Ä–µ–º —Ç–æ–ª—å–∫–æ –∏–Ω–¥–µ–∫—Å—ã (–∫–ª—é—á–∏)
  
      return {
        bestMoves: sortedRecommended.length > 0 ? sortedRecommended.slice(0, 2) : [],
        worstMoves: sortedNotRecommended.length > 0 ? sortedNotRecommended.slice(0, 2) : [],
      };
  }